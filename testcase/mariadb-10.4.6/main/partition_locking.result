# Original tests for WL#4443
# Must have SequoiaDB as engine to get the same statistics results.
# embedded uses MyISAM as default. CREATE SELECT uses the default engine.
SET @old_default_storage_engine = @@default_storage_engine;
SET @@default_storage_engine = 'SequoiaDB';
CREATE DATABASE test_partition_locking;
USE test_partition_locking;
CREATE TABLE t1 (a int PRIMARY KEY, b varchar(128), KEY (b))
ENGINE = SequoiaDB 
PARTITION BY HASH (a) PARTITIONS 13;
CREATE TABLE t2 (a int PRIMARY KEY AUTO_INCREMENT, b varchar(128))
ENGINE = SequoiaDB 
PARTITION BY HASH (a) PARTITIONS 13;
#
#
# Test how INSERT prune locks
# First test, no defaults
#
FLUSH STATUS;
INSERT INTO t1 VALUES (1, 'First row, p1');
# 1 commit
FLUSH STATUS;
INSERT INTO t1 VALUES (1, 'First row, duplicate');
ERROR 23000: Duplicate entry '{ "a": 1 }' for key 'PRIMARY'
# 1 rollback
FLUSH STATUS;
INSERT INTO t1 VALUES (0, 'First row, p0'), (2, 'First row, p2'),
(3, 'First row, p3'), (4, 'First row, p4');
# 1 commit
FLUSH STATUS;
INSERT INTO t1 VALUES (1 * 13, 'Second row, p0'), (2 * 13, 'Third row, p0'),
(3 * 13, 'Fourth row, p0'), (4 * 13, 'Fifth row, p0');
# 1 commit
#
# INSERT with auto increment, lock pruning
#
FLUSH STATUS;
INSERT INTO t2 VALUES (NULL, 'First auto-inc row');
# Auto increment value is not known until write.
# 1 commit
FLUSH STATUS;
INSERT INTO t2 (b) VALUES ('Second auto-inc row');
# Auto increment value is not known until write.
# 1 commit
FLUSH STATUS;
INSERT INTO t2 VALUES (10, "First row, p10");
# Insert pruning on tables with auto increment is not yet supported
# 1 commit
#
# UPDATE with auto increment, lock pruning
#
FLUSH STATUS;
UPDATE t2 SET b = CONCAT(b, ", UPDATED") WHERE a = 10;
# 1 read_key + 1 update + 1 commit
#
# Test of pruning with secondary column auto_inc INSERT
#
CREATE TABLE t3 (a INT, b INT AUTO_INCREMENT, PRIMARY KEY (a, b))
ENGINE = SequoiaDB 
PARTITION BY HASH (a) PARTITIONS 5;
FLUSH STATUS;
INSERT INTO t3 VALUES (1, 1);
# 4 locks (table + partition lock/unlock)
# No commits, since MyISAM!
FLUSH STATUS;
INSERT INTO t3 VALUES (1, NULL);
# 4 locks (table + partition lock/unlock)
SELECT @@sql_mode;
@@sql_mode
STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION
SET @old_sql_mode = @@sql_mode;
SET @@sql_mode = 'NO_AUTO_VALUE_ON_ZERO';
SELECT @@sql_mode;
@@sql_mode
NO_AUTO_VALUE_ON_ZERO
FLUSH STATUS;
INSERT INTO t3 VALUES (1, 0);
# 4 locks (table + partition lock/unlock)
SET @@sql_mode = @old_sql_mode;
SELECT @@sql_mode;
@@sql_mode
STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION
FLUSH STATUS;
INSERT INTO t3 VALUES (1, 0);
# 4 locks (table + partition lock/unlock)
SELECT * FROM t3;
a	b
1	0
1	1
1	2
1	3
DROP TABLE t3;
#
# Test handling of INSERT INTO <table> VALUES (<all fields specified>)
#
CREATE TABLE t3 (a INT, b CHAR(10)) PARTITION BY HASH (a) PARTITIONS 2;
FLUSH STATUS;
INSERT INTO t3 VALUES (1, "Test 1");
FLUSH STATUS;
INSERT INTO t3 VALUES (2, "Test 2"), (3, "Test 3"), (4, "Test 4");
FLUSH STATUS;
INSERT INTO t3 VALUES (6, "Test 6"), (8, "Test 8"), (10, "Test 10");
FLUSH STATUS;
INSERT INTO t3 VALUES (5, "Test 5"), (7, "Test 7"), (9, "Test 9");
FLUSH STATUS;
INSERT INTO t3 VALUES (0, "Test 0");
FLUSH STATUS;
INSERT INTO t3 (a, b) VALUES (1, "Test 1");
FLUSH STATUS;
INSERT INTO t3 (a, b) VALUES (2, "Test 2"), (3, "Test 3"), (4, "Test 4");
FLUSH STATUS;
INSERT INTO t3 (a, b) VALUES (6, "Test 6"), (8, "Test 8"), (10, "Test 10");
FLUSH STATUS;
INSERT INTO t3 (a, b) VALUES (5, "Test 5"), (7, "Test 7"), (9, "Test 9");
FLUSH STATUS;
INSERT INTO t3 (a, b) VALUES (0, "Test 0");
#
# Test handling of
# INSERT INTO <table> VALUES (<not all fields specified>)
#
FLUSH STATUS;
INSERT INTO t3 (a) VALUES (1);
FLUSH STATUS;
INSERT INTO t3 (a) VALUES (2), (3), (4);
FLUSH STATUS;
INSERT INTO t3 (a) VALUES (6), (8), (10);
FLUSH STATUS;
INSERT INTO t3 (a) VALUES (5), (7), (9);
FLUSH STATUS;
INSERT INTO t3 (b) VALUES ("Only b 1");
FLUSH STATUS;
INSERT INTO t3 (b) VALUES ("Only b 2"), ("Only b 3");
SELECT * FROM t3 ORDER BY a, b;
a	b
NULL	Only b 1
NULL	Only b 2
NULL	Only b 3
0	Test 0
0	Test 0
1	NULL
1	Test 1
1	Test 1
2	NULL
2	Test 2
2	Test 2
3	NULL
3	Test 3
3	Test 3
4	NULL
4	Test 4
4	Test 4
5	NULL
5	Test 5
5	Test 5
6	NULL
6	Test 6
6	Test 6
7	NULL
7	Test 7
7	Test 7
8	NULL
8	Test 8
8	Test 8
9	NULL
9	Test 9
9	Test 9
10	NULL
10	Test 10
10	Test 10
DROP TABLE t3;
#
# Test of insert pruning with subpartitions
#
# I've placed the varchar column before the int column for better
# distribution by LINEAR KEY.
CREATE TABLE t3
(a int DEFAULT 10,
b varchar(64) DEFAULT "Default",
c varchar(64) DEFAULT "Default",
d int unsigned DEFAULT 9,
e varchar(255) DEFAULT "Default-filler.filler.filler.",
PRIMARY KEY (a,b,c,d))
PARTITION BY RANGE COLUMNS (a, b)
SUBPARTITION BY LINEAR KEY (d, c)
SUBPARTITIONS 4
(PARTITION pNeg VALUES LESS THAN (0, ""),
PARTITION `p0-9` VALUES LESS THAN (9, MAXVALUE),
PARTITION p10 VALUES LESS THAN (10, MAXVALUE),
PARTITION `p11-100` VALUES LESS THAN (99, MAXVALUE));
#
# Test INSERT with
# empty field specifier list and empty value list
#
FLUSH STATUS;
INSERT INTO t3 () VALUES ();
#
# Test INSERT with
# no field specifier list and full value list, including DEFAULT
# specifier
#
FLUSH STATUS;
INSERT IGNORE INTO t3 VALUES (-1, "ZZZzzzz", "yyyYYY", -1, DEFAULT);
Warnings:
Warning	1264	Out of range value for column 'd' at row 1
#
# Test INSERT with
# empty field specifier list and full value list, including NULL
#
FLUSH STATUS;
INSERT INTO t3 () VALUES (0, "", "", 0, NULL);
#
# Test INSERT with field specifier list for only some fields
#
FLUSH STATUS;
INSERT INTO t3 (a) VALUES (1);
FLUSH STATUS;
INSERT INTO t3 (a, b) VALUES (1, "Part expr fulfilled"),
(10, "Part expr fulfilled");
FLUSH STATUS;
INSERT INTO t3 (d) VALUES (1), (2);
FLUSH STATUS;
INSERT INTO t3 (c, d) VALUES ("Subpart expr fulfilled", 1);
FLUSH STATUS;
INSERT INTO t3 (a, b, d) VALUES (10, "Full part, half subpart", 1),
(12, "Full part, half subpart", 1),
(12, "Full part, half subpart", 2),
(12, "Full part, half subpart", 3),
(12, "Full part, half subpart", 4),
(12, "Full part, half subpart", 0);
# d = 0 and d = 4 goes to the same subpart!
FLUSH STATUS;
INSERT INTO t3 (a, b, c) VALUES (1, "Full part", "Half subpart");
# Adding 'Default' as padding to see if LINEAR KEY uses different parts.
FLUSH STATUS;
INSERT INTO t3 (a, c, d) VALUES (12, "Half part, full subpart", 1),
(12, "Half part, full subpartDefault", 1),
(12, "Half part, full subpart Default", 1);
# First and last row goes to the same subpartition.
FLUSH STATUS;
INSERT INTO t3 (b, c, d) VALUES ("Half part", "Full subpart", 1);
FLUSH STATUS;
#
# Test INSERT with full field specifier list and full value list
#
INSERT INTO t3 (a, b, c, d) VALUES (1, "Full part", "Full subpart", 1);
#
# Test INSERT with no field specifier list and empty value list
# (need to delete previous inserted default row first...)
#
DELETE FROM t3 WHERE a = 10 AND b = 'Default' AND c = 'Default' AND D = 9;
FLUSH STATUS;
INSERT INTO t3 VALUES ();
#
# Verifing result
#
SELECT * FROM t3;
a	b	c	d	e
-1	ZZZzzzz	yyyYYY	0	Default-filler.filler.filler.
0			0	NULL
1	Default	Default	9	Default-filler.filler.filler.
1	Full part	Full subpart	1	Default-filler.filler.filler.
1	Full part	Half subpart	9	Default-filler.filler.filler.
1	Part expr fulfilled	Default	9	Default-filler.filler.filler.
10	Default	Default	1	Default-filler.filler.filler.
10	Default	Default	2	Default-filler.filler.filler.
10	Default	Default	9	Default-filler.filler.filler.
10	Default	Subpart expr fulfilled	1	Default-filler.filler.filler.
10	Full part, half subpart	Default	1	Default-filler.filler.filler.
10	Half part	Full subpart	1	Default-filler.filler.filler.
10	Part expr fulfilled	Default	9	Default-filler.filler.filler.
12	Default	Half part, full subpart	1	Default-filler.filler.filler.
12	Default	Half part, full subpart Default	1	Default-filler.filler.filler.
12	Default	Half part, full subpartDefault	1	Default-filler.filler.filler.
12	Full part, half subpart	Default	0	Default-filler.filler.filler.
12	Full part, half subpart	Default	1	Default-filler.filler.filler.
12	Full part, half subpart	Default	2	Default-filler.filler.filler.
12	Full part, half subpart	Default	3	Default-filler.filler.filler.
12	Full part, half subpart	Default	4	Default-filler.filler.filler.
SELECT d, c FROM t3 PARTITION(`p11-100sp0`);
ERROR 0A000: Cannot specify HASH or KEY partitions
SELECT d, c FROM t3 PARTITION(`p11-100sp1`);
ERROR 0A000: Cannot specify HASH or KEY partitions
SELECT d, c FROM t3 PARTITION(`p11-100sp2`);
ERROR 0A000: Cannot specify HASH or KEY partitions
SELECT d, c FROM t3 PARTITION(`p11-100sp3`);
ERROR 0A000: Cannot specify HASH or KEY partitions
#
# Test INSERT with no field specifier list and empty value list
# (need to delete previous inserted default row first...)
#
DELETE FROM t3 WHERE a = 10 AND b = 'Default' AND c = 'Default' AND D = 9;
FLUSH STATUS;
INSERT INTO t3 VALUES ();
FLUSH STATUS;
#
# Test INSERT with field specifier list for only some fields
# (need to delete previous inserted default row first...)
#
DELETE FROM t3
WHERE a = 10 AND b = "Default" AND c = "Default" AND d = 9;
FLUSH STATUS;
INSERT INTO t3 (b, d, e) VALUES (DEFAULT, DEFAULT, "All default!");
FLUSH STATUS;
#
# Test UPDATE of non PK field in default row
#
UPDATE t3
SET e = CONCAT(e, ", updated")
WHERE a = 10 AND b = "Default" AND c = "Default" AND d = 9;
FLUSH STATUS;
#
# Test UPDATE of PK field + non PK field in default row
#
UPDATE t3
SET a = DEFAULT, b = "Not DEFAULT!", e = CONCAT(e, ", updated2")
WHERE a = 10 AND b = "Default" AND c = "Default" AND d = 9;
ERROR HY000: Sharding key cannot be updated
FLUSH STATUS;
#
# Test REPLACE of default row (INSERT, since not duplicate)
#
REPLACE INTO t3 (e) VALUES ("New default row");
FLUSH STATUS;
SELECT * FROM t3
WHERE a = 10 AND b = "Default" AND c = "Default" AND d = 9;
a	b	c	d	e
10	Default	Default	9	New default row
FLUSH STATUS;
FLUSH STATUS;
#
# Test REPLACE of default row (REPLACE, since duplicate exists)
#
REPLACE INTO t3 (e) VALUES ("Newest default row");
#
# Test SELECT with explicit partition selection
#
FLUSH STATUS;
SELECT * FROM t3 PARTITION (p10);
ERROR 0A000: Cannot specify partitions sharded by multi columns
FLUSH STATUS;
FLUSH STATUS;
DROP TABLE t3;
#
# End of LOCK TABLE test.
#
#
# Test INSERT with timestamp column NO default function
#
SELECT UNIX_TIMESTAMP('2011-01-01 00:00:00') as time_t,
UNIX_TIMESTAMP('2011-01-01 00:00:00') % 3 as part,
1234567890 % 3 as part2;
time_t	part	part2
1293811200	0	0
SET sql_mode = 'NO_ENGINE_SUBSTITUTION';
CREATE TABLE t3
(a timestamp DEFAULT 0,
b char(10),
PRIMARY KEY (a))
PARTITION BY HASH (UNIX_TIMESTAMP(a)) PARTITIONS 3;
SHOW CREATE TABLE t3;
Table	Create Table
t3	CREATE TABLE `t3` (
  `a` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00',
  `b` char(10) DEFAULT NULL,
  PRIMARY KEY (`a`)
) ENGINE=SequoiaDB DEFAULT CHARSET=latin1
 PARTITION BY HASH (unix_timestamp(`a`))
PARTITIONS 3
DROP TABLE t3;
#
# Test INSERT with timestamp column DEFAULT INSERT + UPDATE
#
CREATE TABLE t3
(a timestamp DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
b char(10),
PRIMARY KEY (a))
PARTITION BY HASH (UNIX_TIMESTAMP(a)) PARTITIONS 3;
SHOW CREATE TABLE t3;
Table	Create Table
t3	CREATE TABLE `t3` (
  `a` timestamp NOT NULL DEFAULT current_timestamp() ON UPDATE current_timestamp(),
  `b` char(10) DEFAULT NULL,
  PRIMARY KEY (`a`)
) ENGINE=SequoiaDB DEFAULT CHARSET=latin1
 PARTITION BY HASH (unix_timestamp(`a`))
PARTITIONS 3
DROP TABLE t3;
#
# Test INSERT with timestamp column DEFAULT UPDATE
#
CREATE TABLE t3
(a timestamp DEFAULT 0 ON UPDATE CURRENT_TIMESTAMP,
b char(10),
PRIMARY KEY (a))
PARTITION BY HASH (UNIX_TIMESTAMP(a)) PARTITIONS 3;
SHOW CREATE TABLE t3;
Table	Create Table
t3	CREATE TABLE `t3` (
  `a` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00' ON UPDATE current_timestamp(),
  `b` char(10) DEFAULT NULL,
  PRIMARY KEY (`a`)
) ENGINE=SequoiaDB DEFAULT CHARSET=latin1
 PARTITION BY HASH (unix_timestamp(`a`))
PARTITIONS 3
DROP TABLE t3;
#
# Test INSERT with timestamp column DEFAULT INSERT
#
CREATE TABLE t3
(a timestamp DEFAULT CURRENT_TIMESTAMP,
b char(10),
PRIMARY KEY (a))
PARTITION BY HASH (UNIX_TIMESTAMP(a)) PARTITIONS 3;
SHOW CREATE TABLE t3;
Table	Create Table
t3	CREATE TABLE `t3` (
  `a` timestamp NOT NULL DEFAULT current_timestamp(),
  `b` char(10) DEFAULT NULL,
  PRIMARY KEY (`a`)
) ENGINE=SequoiaDB DEFAULT CHARSET=latin1
 PARTITION BY HASH (unix_timestamp(`a`))
PARTITIONS 3
DROP TABLE t3;
#
# Test INSERT with DATETIME column NO default function
#
CREATE TABLE t3
(a DATETIME DEFAULT 0,
b char(10),
PRIMARY KEY (a))
PARTITION BY KEY (a) PARTITIONS 3;
SHOW CREATE TABLE t3;
Table	Create Table
t3	CREATE TABLE `t3` (
  `a` datetime NOT NULL DEFAULT '0000-00-00 00:00:00',
  `b` char(10) DEFAULT NULL,
  PRIMARY KEY (`a`)
) ENGINE=SequoiaDB DEFAULT CHARSET=latin1
 PARTITION BY KEY (`a`)
PARTITIONS 3
DROP TABLE t3;
#
# Test INSERT with DATETIME column DEFAULT INSERT + UPDATE
#
CREATE TABLE t3
(a DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
b char(10),
PRIMARY KEY (a))
PARTITION BY KEY (a) PARTITIONS 3;
SHOW CREATE TABLE t3;
Table	Create Table
t3	CREATE TABLE `t3` (
  `a` datetime NOT NULL DEFAULT current_timestamp() ON UPDATE current_timestamp(),
  `b` char(10) DEFAULT NULL,
  PRIMARY KEY (`a`)
) ENGINE=SequoiaDB DEFAULT CHARSET=latin1
 PARTITION BY KEY (`a`)
PARTITIONS 3
DROP TABLE t3;
#
# Test INSERT with DATETIME column DEFAULT UPDATE
#
CREATE TABLE t3
(a DATETIME DEFAULT 0 ON UPDATE CURRENT_TIMESTAMP,
b char(10),
PRIMARY KEY (a))
PARTITION BY KEY (a) PARTITIONS 3;
SHOW CREATE TABLE t3;
Table	Create Table
t3	CREATE TABLE `t3` (
  `a` datetime NOT NULL DEFAULT '0000-00-00 00:00:00' ON UPDATE current_timestamp(),
  `b` char(10) DEFAULT NULL,
  PRIMARY KEY (`a`)
) ENGINE=SequoiaDB DEFAULT CHARSET=latin1
 PARTITION BY KEY (`a`)
PARTITIONS 3
DROP TABLE t3;
#
# Test INSERT with DATETIME column DEFAULT INSERT
#
CREATE TABLE t3
(a DATETIME DEFAULT CURRENT_TIMESTAMP,
b char(10),
PRIMARY KEY (a))
PARTITION BY KEY (a) PARTITIONS 3;
SHOW CREATE TABLE t3;
Table	Create Table
t3	CREATE TABLE `t3` (
  `a` datetime NOT NULL DEFAULT current_timestamp(),
  `b` char(10) DEFAULT NULL,
  PRIMARY KEY (`a`)
) ENGINE=SequoiaDB DEFAULT CHARSET=latin1
 PARTITION BY KEY (`a`)
PARTITIONS 3
DROP TABLE t3;
SET sql_mode = default;
#
# Test INSERT SELECT
#
FLUSH STATUS;
TRUNCATE TABLE t2;
# All partitions needs to be locked
# 1 commit
FLUSH STATUS;
INSERT INTO t2 SELECT a, b FROM t1 WHERE a IN (1,4);
# All partitions in t2 needs to be locked (no propagation from t1 yet).
# 2 partitions in t1 needs to be locked (for 1 and 4)
# 2 read_first, read_key and read_next.
# 1 commit
#
# Test TRUNCATE PARTITION
#
FLUSH STATUS;
ALTER TABLE t2 TRUNCATE PARTITION p1;
ERROR 0A000: Cannot specify HASH or KEY partitions
#
# Test insert on duplicated key update
#
FLUSH STATUS;
INSERT INTO t1 VALUES (65, "No duplicate")
ON DUPLICATE KEY UPDATE b = CONCAT(b, ", INSERT_DUP_KEY_UPDATE");
# 1 write (insert)
# 1 commit
FLUSH STATUS;
INSERT INTO t1 VALUES (65, "No duplicate")
ON DUPLICATE KEY UPDATE b = CONCAT(b, ", INSERT_DUP_KEY_UPDATE");
# 1 read_key
# 1 update
# 1 commit
FLUSH STATUS;
INSERT INTO t1 VALUES (78, "No duplicate")
ON DUPLICATE KEY UPDATE a = a + 13, b = CONCAT(b, ", INSERT_DUP_KEY_UPDATE");
# If partitioning column is updated, no pruning
# 1 read_key
# 1 update
# 1 commit
INSERT INTO t1 VALUES (78, "No duplicate")
ON DUPLICATE KEY UPDATE a = a + 13,
b = CONCAT(b, ", INSERT_DUP_KEY_UPDATE third");
ERROR HY000: Sharding key cannot be updated
# If partitioning column is updated, no pruning
# 1 commit
FLUSH STATUS;
INSERT INTO t1 VALUES (78, "No duplicate")
ON DUPLICATE KEY UPDATE a = a + 13,
b = CONCAT(b, ", INSERT_DUP_KEY_UPDATE fail?");
ERROR HY000: Sharding key cannot be updated
# If partitioning column is updated, no pruning
# 1 read_key
# 1 update
# 1 rollback
#
# Test replace
#
FLUSH STATUS;
REPLACE INTO t1 VALUES (5, "REPLACE first");
# 1 write
# 1 commit
FLUSH STATUS;
REPLACE INTO t1 VALUES (5, "REPLACE second");
# 1 write
# 1 read_key
# 1 update (NOTE: write_record() may cheat instead of delete/insert!)
# 1 rollback
#
# Test SELECT
#
FLUSH STATUS;
SELECT * FROM t1 ORDER BY a;
a	b
0	First row, p0
1	First row, p1
2	First row, p2
3	First row, p3
4	First row, p4
5	REPLACE second
13	Second row, p0
26	Third row, p0
39	Fourth row, p0
52	Fifth row, p0
65	No duplicate, INSERT_DUP_KEY_UPDATE
78	No duplicate
# 13 read_first
# 13 read_key
# 15 read_next
FLUSH STATUS;
SELECT * FROM t1 WHERE a IN (0, 1, 4) ORDER BY a;
a	b
0	First row, p0
1	First row, p1
4	First row, p4
# 3 read_first, read_key
# 12 read_next
FLUSH STATUS;
SELECT * FROM t1 WHERE a IN (13, 26, 39, 52);
a	b
13	Second row, p0
26	Third row, p0
39	Fourth row, p0
52	Fifth row, p0
# 1 read_first, read_key
# 9 read_next
FLUSH STATUS;
SELECT * FROM t1 WHERE a = 3;
a	b
3	First row, p3
# 1 read_key
FLUSH STATUS;
SELECT * FROM t1 WHERE b LIKE 'First%' ORDER BY a;
a	b
0	First row, p0
1	First row, p1
2	First row, p2
3	First row, p3
4	First row, p4
# 13 read_key
# 5 read_next
#
# Test pruning of non static values
# They will need to lock all partitions, but will allow scan pruning
# due to a second pruning call in optimize.
#
CREATE TABLE t3 (a INT);
INSERT INTO t3 VALUES (1);
FLUSH STATUS;
SELECT * FROM t1 WHERE a = (SELECT a FROM t3);
a	b
1	First row, p1
# 1 read_first (NOTE only reads from one partition!)
# 2 read_key
# 2 read_rnd_next
FLUSH STATUS;
SELECT t1.a FROM t1 INNER JOIN t3 ON t1.a = t3.a;
a
1
# 1 read_first (NOTE only reads from one partition!)
# 2 read_key
FLUSH STATUS;
FLUSH STATUS;
FLUSH STATUS;
SELECT * FROM t1 WHERE a = 1;
a	b
1	First row, p1
# 1 read_key
FLUSH STATUS;
SELECT * FROM t1 WHERE a = (SELECT COUNT(*) FROM t3);
a	b
1	First row, p1
# 1 read_first
# 2 read_key, read_rnd_next
#
# Test of non indexed partition column
#
CREATE TABLE t4 SELECT a, b FROM t1;
ALTER TABLE t4 PARTITION BY HASH (a) PARTITIONS 5;
FLUSH STATUS;
SELECT * FROM t4 WHERE a = (SELECT a FROM t3);
a	b
1	First row, p1
# 2 read_first, read_key
FLUSH STATUS;
INSERT INTO t3 VALUES (3);
SELECT * FROM t4 WHERE a = (SELECT a FROM t3);
ERROR 21000: Subquery returns more than 1 row
DROP TABLE t3;
DROP TABLE t4;
#
# Test derived tables like SELECT * FROM (SELECT * FROM ...)
#
set @optimizer_switch_saved=@@optimizer_switch;
set optimizer_switch='derived_merge=off';
FLUSH STATUS;
SELECT * FROM (SELECT * FROM t1 WHERE a IN (0,2,3,13,26)) t3;
a	b
0	First row, p0
2	First row, p2
3	First row, p3
13	Second row, p0
26	Third row, p0
# 3 read_first, read_key
# 11 read_next
# 6 read_rnd_next (tmp table)
FLUSH STATUS;
SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0,2,3,13,26)) t3) t4;
a	b
0	First row, p0
2	First row, p2
3	First row, p3
13	Second row, p0
26	Third row, p0
# 3 read_first, read_key
# 11 read_next
# 12 read_rnd_next (tmp table)
#
# Test SELECT ... UNION SELECT ...
#
FLUSH STATUS;
SELECT * FROM t1 UNION SELECT * FROM t2;
a	b
0	First row, p0
1	First row, p1
13	Second row, p0
2	First row, p2
26	Third row, p0
3	First row, p3
39	Fourth row, p0
4	First row, p4
5	REPLACE second
52	Fifth row, p0
65	No duplicate, INSERT_DUP_KEY_UPDATE
78	No duplicate
FLUSH STATUS;
SELECT * FROM t1 WHERE a IN (0, 1, 13, 4) UNION SELECT * FROM t2;
a	b
0	First row, p0
1	First row, p1
4	First row, p4
13	Second row, p0
FLUSH STATUS;
SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4)) t3 UNION SELECT * FROM t2;
a	b
0	First row, p0
1	First row, p1
4	First row, p4
13	Second row, p0
FLUSH STATUS;
SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4) UNION SELECT * FROM t2) t3) t4;
a	b
0	First row, p0
1	First row, p1
4	First row, p4
13	Second row, p0
FLUSH STATUS;
SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4)) t3 UNION SELECT * FROM t2) t4;
a	b
0	First row, p0
1	First row, p1
4	First row, p4
13	Second row, p0
FLUSH STATUS;
SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4)) t3) t4 UNION SELECT * FROM t2;
a	b
0	First row, p0
1	First row, p1
4	First row, p4
13	Second row, p0
FLUSH STATUS;
SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4)) t3 UNION SELECT * FROM t2 WHERE a = 1) t4;
a	b
0	First row, p0
1	First row, p1
4	First row, p4
13	Second row, p0
set @@optimizer_switch=@optimizer_switch_saved;
#
# Test UPDATE
#
SELECT * FROM t1 ORDER BY a;
a	b
0	First row, p0
1	First row, p1
2	First row, p2
3	First row, p3
4	First row, p4
5	REPLACE second
13	Second row, p0
26	Third row, p0
39	Fourth row, p0
52	Fifth row, p0
65	No duplicate, INSERT_DUP_KEY_UPDATE
78	No duplicate
# This should be prunable (does not change the partitioning key)
FLUSH STATUS;
UPDATE t1 SET b = CONCAT(b, ", updated 1") WHERE a IN (13, 26, 39, 52);
# 4 read_key
# 4 update
#
# This should not be prunable (only after implementing 'update pruning')
# i.e if all changed partitioning field is set to constant values,
# set lock_partitions to be a union of read_partition and the matching
# partition for the constants. Easy if all partitioning fields are set,
# probably needs a second round of prune_partitions() with these fields
# set to see if possible to prune locks.
FLUSH STATUS;
UPDATE t1 SET a = 99, b = CONCAT(b, ", updated 2 -> p8") WHERE a = 13;
ERROR HY000: Sharding key cannot be updated
# 2 read_key
# 1 read_rnd
# 1 delete (due to moved to another partition)
# 1 write
#
# This should use ha_update_row instead of ha_write_row + ha_delete_row
FLUSH STATUS;
UPDATE t1 SET a = 13 + 99, b = CONCAT(b, ", updated 3") WHERE a = 99;
# 2 read_key
# 1 read_rnd
# 1 update
#
# This should not be prunable (only after implementing
# 'optimized update pruning', which will probably never happen, since
# it depends on which partitioning type is used (for this only hash is
# simple, but range and list is possible, key is very hard)
FLUSH STATUS;
UPDATE t1 SET a = a + 1, b = CONCAT(b, ", updated 4 -> p9") WHERE a = 112;
# 2 read_key
# 1 read_rnd
# 1 delete (due to moved to another partition)
# 1 write
FLUSH STATUS;
UPDATE t1 SET b = CONCAT(b, ", same as min(a) + 2 in t2") WHERE a = (SELECT MIN(a) + 2 FROM t2);
FLUSH STATUS;
UPDATE t1 SET b = CONCAT(b, ", max(a) in t2: ", (SELECT MAX(a) FROM t2)) WHERE a = 5;
#
# Test multi table UPDATE
#
SELECT * FROM t1 ORDER BY a;
a	b
0	First row, p0
1	First row, p1
2	First row, p2
3	First row, p3, same as min(a) + 2 in t2
4	First row, p4
5	REPLACE second, max(a) in t2: 4
13	Second row, p0, updated 1
26	Third row, p0, updated 1
39	Fourth row, p0, updated 1
52	Fifth row, p0, updated 1
65	No duplicate, INSERT_DUP_KEY_UPDATE
78	No duplicate
SELECT * FROM t2 ORDER BY a;
a	b
1	First row, p1
4	First row, p4
FLUSH STATUS;
UPDATE t1, t2
SET t1.b = CONCAT(t1.b, ", t2.b:", t2.b),
t2.b = CONCAT(t2.b, ", t1.b:", t1.b)
WHERE t2.b = t1.b and t2.a = 4;
# 15 read_key
# 1 read_next, read_rnd
# 2 read_rnd_next
# 2 update
#
# Test CREATE SELECT
#
FLUSH STATUS;
CREATE TABLE t3 SELECT a, b FROM t1 WHERE a IN (0, 1, 13, 113);
SELECT * FROM t3 ORDER BY a;
a	b
0	First row, p0
1	First row, p1
13	Second row, p0, updated 1
DROP TABLE t3;
FLUSH STATUS;
CREATE TABLE t3 SELECT a, b FROM t1 WHERE b LIKE 'First%';
SELECT * FROM t3 ORDER BY a;
a	b
0	First row, p0
1	First row, p1
2	First row, p2
3	First row, p3, same as min(a) + 2 in t2
4	First row, p4, t2.b:First row, p4
DROP TABLE t3;
#
# Test Stored procedures
#
CREATE PROCEDURE sp_insert(a INT, b CHAR(16))
INSERT INTO test_partition_locking.t1 VALUES (a, b);
CREATE PROCEDURE sp_insert_partition(p CHAR(16), a INT, b CHAR(16))
BEGIN
SET @str = CONCAT("INSERT INTO test_partition_locking.t1 PARTITION(", p, ") VALUES (?, ?)");
SET @x = a, @y = b;
PREPARE stmt FROM @str;
EXECUTE stmt USING @x, @y;
DEALLOCATE PREPARE stmt;
END|
CREATE PROCEDURE sp_select_all()
SELECT * FROM test_partition_locking.t1;
CREATE PROCEDURE sp_select_exact(x INT)
SELECT * FROM test_partition_locking.t1 WHERE a = x;
CREATE PROCEDURE sp_select_partition(p CHAR(16))
BEGIN
SET @str = CONCAT("SELECT * FROM test_partition_locking.t1 PARTITION(", p, ")");
PREPARE stmt FROM @str;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;
END|
CREATE PROCEDURE sp_select_range(x INT, y INT)
SELECT * FROM test_partition_locking.t1 WHERE a between x and y;
FLUSH STATUS;
CALL sp_insert(313,"Test313");
FLUSH STATUS;
CALL sp_insert_partition("p7", 98, "Test98");
ERROR 0A000: Cannot specify HASH or KEY partitions
FLUSH STATUS;
CALL sp_insert_partition("p8", 111, "Test111");
ERROR 0A000: Cannot specify HASH or KEY partitions
# no proc locking since already in proc cache.
FLUSH STATUS;
CALL sp_insert_partition("p7,p8", 111, "Test111");
ERROR 0A000: Cannot specify HASH or KEY partitions
FLUSH STATUS;
CALL sp_select_all();
a	b
0	First row, p0
1	First row, p1
13	Second row, p0, updated 1
2	First row, p2
26	Third row, p0, updated 1
3	First row, p3, same as min(a) + 2 in t2
313	Test313
39	Fourth row, p0, updated 1
4	First row, p4, t2.b:First row, p4
5	REPLACE second, max(a) in t2: 4
52	Fifth row, p0, updated 1
65	No duplicate, INSERT_DUP_KEY_UPDATE
78	No duplicate
FLUSH STATUS;
CALL sp_select_exact(98);
a	b
FLUSH STATUS;
CALL sp_select_partition("p7");
ERROR 0A000: Cannot specify HASH or KEY partitions
FLUSH STATUS;
CALL sp_select_partition("p8");
ERROR 0A000: Cannot specify HASH or KEY partitions
# no proc locking since already in proc cache.
FLUSH STATUS;
CALL sp_select_partition("p7,p8");
ERROR 0A000: Cannot specify HASH or KEY partitions
FLUSH STATUS;
CALL sp_select_range(1,5);
a	b
1	First row, p1
2	First row, p2
3	First row, p3, same as min(a) + 2 in t2
4	First row, p4, t2.b:First row, p4
5	REPLACE second, max(a) in t2: 4
DROP PROCEDURE sp_insert;
DROP PROCEDURE sp_insert_partition;
DROP PROCEDURE sp_select_all;
DROP PROCEDURE sp_select_partition;
DROP PROCEDURE sp_select_range;
DROP PROCEDURE sp_select_exact;
#
# Test EXPLAIN DELETE
#
SELECT * FROM t1 ORDER BY a;
a	b
0	First row, p0
1	First row, p1
2	First row, p2
3	First row, p3, same as min(a) + 2 in t2
4	First row, p4, t2.b:First row, p4
5	REPLACE second, max(a) in t2: 4
13	Second row, p0, updated 1
26	Third row, p0, updated 1
39	Fourth row, p0, updated 1
52	Fifth row, p0, updated 1
65	No duplicate, INSERT_DUP_KEY_UPDATE
78	No duplicate
313	Test313
FLUSH STATUS;
#
# Test DELETE
#
FLUSH STATUS;
DELETE FROM t1 WHERE a = 105;
# 1 read_key
# 1 delete
FLUSH STATUS;
DELETE FROM t1 WHERE b = "No duplicate";
# 13 read_key
# 1 read_next (if more matches after the first match)
# 1 delete
FLUSH STATUS;
DELETE FROM t1 WHERE a = (SELECT a + 90 FROM t2 WHERE a = 1);
# 2 read_key
# 2 read_next (if more matches after the first match)
# 1 delete
FLUSH STATUS;
DELETE FROM t1 PARTITION (p0)
WHERE a = (SELECT a + 2 FROM t2 WHERE a = 1);
ERROR 0A000: Cannot specify HASH or KEY partitions
# Impossible delete, all partitions pruned away after locking!
# 1 read_key
#
# Test multi table DELETE
#
SELECT * FROM t1 ORDER BY a;
a	b
0	First row, p0
1	First row, p1
2	First row, p2
3	First row, p3, same as min(a) + 2 in t2
4	First row, p4, t2.b:First row, p4
5	REPLACE second, max(a) in t2: 4
13	Second row, p0, updated 1
26	Third row, p0, updated 1
39	Fourth row, p0, updated 1
52	Fifth row, p0, updated 1
65	No duplicate, INSERT_DUP_KEY_UPDATE
313	Test313
SELECT * FROM t2 ORDER BY a;
a	b
1	First row, p1
4	First row, p4, t1.b:First row, p4
FLUSH STATUS;
DELETE t1, t2 FROM t1, t2
WHERE t1.a = t2.a AND t1.b = 'First row, p1';
# 15 read_key
# 2 delete
FLUSH STATUS;
DELETE FROM t2, t1 USING t2, t1
WHERE t1.b = t2.b AND t2.a = 4;
SELECT * FROM t1 ORDER BY a;
a	b
0	First row, p0
2	First row, p2
3	First row, p3, same as min(a) + 2 in t2
4	First row, p4, t2.b:First row, p4
5	REPLACE second, max(a) in t2: 4
13	Second row, p0, updated 1
26	Third row, p0, updated 1
39	Fourth row, p0, updated 1
52	Fifth row, p0, updated 1
65	No duplicate, INSERT_DUP_KEY_UPDATE
313	Test313
SELECT * FROM t2 ORDER BY a;
a	b
4	First row, p4, t1.b:First row, p4
#
# Test triggers
# Tables used in triggers cannot be pruned for locks.
# Tables with triggers cannot be pruned for locks if
# BEFORE INSERT/UPDATE trigger uses any partitioning columns.
#
CREATE TABLE t3
(old_a int,
new_a int,
old_b varchar(255),
new_b varchar(255),
key (new_a, new_b),
key(new_b))
PARTITION BY HASH (new_a) PARTITIONS 5;
CREATE TRIGGER t1_after_insert AFTER INSERT
ON t1 FOR EACH ROW
INSERT INTO t3 VALUES (2, NEW.a, NULL, CONCAT("AI: ", NEW.b));
CREATE TRIGGER t1_after_update AFTER UPDATE
ON t1 FOR EACH ROW
INSERT INTO t3 VALUES (OLD.a, NEW.a, CONCAT("AU: ", OLD.b), CONCAT("AU: ", NEW.b));
FLUSH STATUS;
INSERT INTO t1 VALUES (2, "First row, p2")
ON DUPLICATE KEY UPDATE b = CONCAT(b, ", duplicate key 2");
# (t1 to insert, t3 after insert trigger, t3 after update trigger)
SELECT * FROM t1 WHERE a = 2;
a	b
2	First row, p2, duplicate key 2
FLUSH STATUS;
REPLACE INTO t1 VALUES (0, "First row, p0 REPLACED");
# (t1 to replace, t3 after insert trigger)
# Note that since there is no delete trigger, REPLACE cheats by
# doing update instead of delete+insert!
SELECT * FROM t1 WHERE a = 0;
a	b
0	First row, p0 REPLACED
FLUSH STATUS;
# (t1 to insert, t3 after update trigger)
CREATE TRIGGER t1_after_delete AFTER DELETE
ON t1 FOR EACH ROW
INSERT INTO t3 VALUES (OLD.a, NULL, CONCAT("AD: ", OLD.b), NULL);
FLUSH STATUS;
REPLACE INTO t1 VALUES (0, "First row, p0 REPLACED2");
# (t1 to replace, t3 after insert trigger, t3 after delete trigger)
# Note that now it does delete+insert instead, due to delete trigger!
SELECT * FROM t1 WHERE a = 0;
a	b
0	First row, p0 REPLACED2
CREATE TRIGGER t1_before_delete BEFORE DELETE
ON t1 FOR EACH ROW
INSERT INTO t3 VALUES (OLD.a, NULL, CONCAT("BD: ", OLD.b), NULL);
FLUSH STATUS;
REPLACE INTO t1 VALUES (0, "First row, p0 REPLACED3");
# (t1 to replace, t3 after insert trigger, t3 before delete trigger,
#  t3 after delete trigger)
SELECT * FROM t1 WHERE a = 0;
a	b
0	First row, p0 REPLACED3
CREATE TRIGGER t1_before_update BEFORE UPDATE
ON t1 FOR EACH ROW
INSERT INTO t3 VALUES (OLD.a, NEW.a, CONCAT("BU: ", OLD.b), CONCAT("BU: ", NEW.b));
FLUSH STATUS;
INSERT INTO t1 VALUES (2, "First row, p2")
ON DUPLICATE KEY UPDATE b = CONCAT(b, ", duplicate key 2");
# No pruning possible, due to BEFORE UPDATE trigger
# t1, t3 after insert, t3 before update, t3 after update
SELECT * FROM t1 WHERE a = 2;
a	b
2	First row, p2, duplicate key 2, duplicate key 2
FLUSH STATUS;
REPLACE INTO t1 VALUES (0, "First row, p0 REPLACED4");
# t1, t3 after insert, t3 before delete, t3 after delete
SELECT * FROM t1 WHERE a = 0;
a	b
0	First row, p0 REPLACED4
FLUSH STATUS;
# No pruning possible, due to BEFORE UPDATE trigger
# t1, before update, after update
SELECT * FROM t1 WHERE a = 3;
a	b
3	First row, p3, same as min(a) + 2 in t2
FLUSH STATUS;
UPDATE t1 SET b = CONCAT(b, ", UPDATED2") WHERE a = 3;
# t1, before update, after update
SELECT * FROM t1 WHERE a = 3;
a	b
3	First row, p3, same as min(a) + 2 in t2, UPDATED2
FLUSH STATUS;
INSERT INTO t1 VALUES (12, "First row, p12");
# t1, t3 after insert trigger
CREATE TRIGGER t1_before_insert BEFORE INSERT
ON t1 FOR EACH ROW
INSERT INTO t3 VALUES (1, NEW.a, NULL, CONCAT("BI: ", NEW.b));
FLUSH STATUS;
INSERT INTO t1 VALUES (11, "First row, p11");
# Nothing can be pruned, due to triggers.
# t1, t3 before insert, t3 after insert.
FLUSH STATUS;
# t1, t3 before delete trigger, t3 after delete trigger
# part 7, part 0-4, part 0-4.
SELECT * FROM t1 ORDER BY a;
a	b
0	First row, p0 REPLACED4
2	First row, p2, duplicate key 2, duplicate key 2
3	First row, p3, same as min(a) + 2 in t2, UPDATED2
4	First row, p4, t2.b:First row, p4
5	REPLACE second, max(a) in t2: 4
11	First row, p11
12	First row, p12
13	Second row, p0, updated 1
26	Third row, p0, updated 1
39	Fourth row, p0, updated 1
52	Fifth row, p0, updated 1
65	No duplicate, INSERT_DUP_KEY_UPDATE
313	Test313
FLUSH STATUS;
DELETE FROM t1 WHERE a = 98;
# t1, t3 before delete trigger, t3 after delete trigger
SELECT * FROM t1 ORDER BY a;
a	b
0	First row, p0 REPLACED4
2	First row, p2, duplicate key 2, duplicate key 2
3	First row, p3, same as min(a) + 2 in t2, UPDATED2
4	First row, p4, t2.b:First row, p4
5	REPLACE second, max(a) in t2: 4
11	First row, p11
12	First row, p12
13	Second row, p0, updated 1
26	Third row, p0, updated 1
39	Fourth row, p0, updated 1
52	Fifth row, p0, updated 1
65	No duplicate, INSERT_DUP_KEY_UPDATE
313	Test313
SELECT * FROM t2 ORDER BY a;
a	b
4	First row, p4, t1.b:First row, p4
SELECT * FROM t3 ORDER BY new_a;
old_a	new_a	old_b	new_b
1	11	NULL	BI: First row, p11
2	0	NULL	AI: First row, p0 REPLACED
2	0	NULL	AI: First row, p0 REPLACED2
2	0	NULL	AI: First row, p0 REPLACED3
2	0	NULL	AI: First row, p0 REPLACED4
2	11	NULL	AI: First row, p11
2	12	NULL	AI: First row, p12
2	2	AU: First row, p2	AU: First row, p2, duplicate key 2
2	2	AU: First row, p2, duplicate key 2	AU: First row, p2, duplicate key 2, duplicate key 2
2	2	BU: First row, p2, duplicate key 2	BU: First row, p2, duplicate key 2, duplicate key 2
3	3	AU: First row, p3, same as min(a) + 2 in t2	AU: First row, p3, same as min(a) + 2 in t2, UPDATED2
3	3	BU: First row, p3, same as min(a) + 2 in t2	BU: First row, p3, same as min(a) + 2 in t2, UPDATED2
TRUNCATE TABLE t1;
DROP TRIGGER t1_before_insert;
DROP TRIGGER t1_before_update;
DROP TRIGGER t1_before_delete;
DROP TRIGGER t1_after_insert;
DROP TRIGGER t1_after_update;
DROP TRIGGER t1_after_delete;
#
# Test BEFORE INSERT TRIGGER depending on partitioning column
#
CREATE TRIGGER t1_before_insert BEFORE INSERT
ON t1 FOR EACH ROW
SET NEW.b = CONCAT("b: ", NEW.b, " a: ", NEW.a);
FLUSH STATUS;
INSERT INTO t1 VALUES (0, "first row, p0");
FLUSH STATUS;
INSERT INTO t1 VALUES (0, "Second row, p0")
ON DUPLICATE KEY UPDATE b = CONCAT(b, ", duplicate key");
FLUSH STATUS;
UPDATE t1 SET b = CONCAT(b, ", Updated") WHERE a = 0;
FLUSH STATUS;
UPDATE t1 SET a = 1, b = CONCAT(b, ", a was 0") WHERE a = 0;
ERROR HY000: Sharding key cannot be updated
# Updating partitioning column, no lock pruning
#
# Test BEFORE INSERT TRIGGER not depending on partitioning column
#
DROP TRIGGER t1_before_insert;
CREATE TRIGGER t1_before_insert BEFORE INSERT
ON t1 FOR EACH ROW
SET NEW.b = CONCAT("b: ", NEW.b);
FLUSH STATUS;
INSERT INTO t1 VALUES (0, "Second row, p0")
ON DUPLICATE KEY UPDATE b = CONCAT(b, ", duplicate key");
FLUSH STATUS;
UPDATE t1 SET b = CONCAT(b, ", Updated") WHERE a = 0;
FLUSH STATUS;
UPDATE t1 SET a = 2, b = CONCAT(b, ", a was 0") WHERE a = 0;
ERROR HY000: Sharding key cannot be updated
# Updating partitioning column, no lock pruning
#
# Test BEFORE UPDATE TRIGGER OLD depending on partitioning column.
# Note that it does not update any partitioning column.
#
CREATE TRIGGER t1_before_update BEFORE UPDATE
ON t1 FOR EACH ROW
SET NEW.b = CONCAT("old a: ", OLD.a, " new b: ", NEW.b);
FLUSH STATUS;
INSERT INTO t1 VALUES (0, "2nd p0")
ON DUPLICATE KEY UPDATE b = CONCAT(b, ", dup key");
FLUSH STATUS;
UPDATE t1 SET b = CONCAT(b, ", Updated") WHERE a = 0;
#
# Test BEFORE UPDATE TRIGGER NEW depending on partitioning column.
# Note that it does not update any partitioning column.
#
DROP TRIGGER t1_before_update;
CREATE TRIGGER t1_before_update BEFORE UPDATE
ON t1 FOR EACH ROW
SET NEW.b = CONCAT("new a: ", NEW.a, " new b: ", NEW.b);
#
# Test BEFORE UPDATE TRIGGER not depending on partitioning column
#
DROP TRIGGER t1_before_update;
SELECT * FROM t1 ORDER BY a;
a	b
0	old a: 0 new b: old a: 0 new b: b: first row, p0 a: 0, duplicate key, Updated, duplicate key, Updated, dup key, Updated
DROP TABLE t1, t2, t3;
#
# Test of BEFORE UPDATE triggers and multi UPDATE
#
CREATE TABLE t1 (a int, b varchar(128), KEY (b))
ENGINE = SequoiaDB 
PARTITION BY HASH (a) PARTITIONS 13;
CREATE TABLE t2 (a int PRIMARY KEY, b varchar(128))
ENGINE = SequoiaDB
PARTITION BY HASH (a) PARTITIONS 13;
INSERT INTO t1 VALUES (1, "MultiUpdate1");
INSERT INTO t1 VALUES (2, "MultiUpdate2");
INSERT INTO t2 VALUES (1, "MultiUpdate1");
INSERT INTO t2 VALUES (2, "MultiUpdate2");
CREATE TRIGGER t1_before_update BEFORE UPDATE
ON t1 FOR EACH ROW
SET NEW.b = CONCAT("new1 b: ", NEW.b);
CREATE TRIGGER t2_before_update BEFORE UPDATE
ON t2 FOR EACH ROW
SET NEW.b = CONCAT("new2 a: ", NEW.a, " new2 b: ", NEW.b);
FLUSH STATUS;
UPDATE t1, t2
SET t1.b = CONCAT(t1.b, ",(1) t2.b:", t2.b),
t2.b = CONCAT(t2.b, ",(1) t1.b:", t1.b)
WHERE t2.b = t1.b and t1.a = 1;
# 14 read_first
# 16 read_key
# 2 read_rnd
# 2 update
FLUSH STATUS;
# Trigger touches partitioning column, unable to prune locks
# Trigger touches partitioning column, unable to prune locks
FLUSH STATUS;
UPDATE t1, t2
SET t1.b = CONCAT(t1.b, ",(2) t2.b:", t2.b),
t2.b = CONCAT(t2.b, ",(2) t1.b:", t1.b)
WHERE t1.b = t2.b and t2.a = 2;
# Due to the BEFORE UPDATE trigger on t2 that looks at 'a',
# no locks can be pruned.
# 15 read_key
# 1 read_next, read_rnd
# 2 read_rnd_next
# 2 update
SELECT * FROM t1 ORDER BY a;
a	b
1	new1 b: MultiUpdate1,(1) t2.b:MultiUpdate1
2	new1 b: MultiUpdate2,(2) t2.b:MultiUpdate2
SELECT * FROM t2 ORDER BY a;
a	b
1	new2 a: 1 new2 b: MultiUpdate1,(1) t1.b:MultiUpdate1
2	new2 a: 2 new2 b: MultiUpdate2,(2) t1.b:MultiUpdate2
DROP TABLE t1, t2;
#
# Test constant propagation in WHERE clause
# (Currently no propagation is done before locking).
CREATE TABLE t1 (a int, b varchar(128), KEY (b))
ENGINE = SequoiaDB 
PARTITION BY RANGE (a)
(PARTITION pNeg VALUES LESS THAN (0),
PARTITION p0 VALUES LESS THAN (1),
PARTITION p1 VALUES LESS THAN (2),
PARTITION p2 VALUES LESS THAN (3),
PARTITION p3 VALUES LESS THAN (4),
PARTITION pMax VALUES LESS THAN MAXVALUE);
CREATE TABLE t2 (a int PRIMARY KEY, b varchar(128))
ENGINE = SequoiaDB 
PARTITION BY RANGE (a)
(PARTITION pNeg VALUES LESS THAN (0),
PARTITION p0 VALUES LESS THAN (1),
PARTITION p1 VALUES LESS THAN (2),
PARTITION p2 VALUES LESS THAN (3),
PARTITION p3 VALUES LESS THAN (4),
PARTITION pMax VALUES LESS THAN MAXVALUE);
INSERT INTO t1 VALUES (1, "Const1");
INSERT INTO t2 VALUES (1, "Const1");
INSERT INTO t1 VALUES (2, "Const2");
INSERT INTO t2 VALUES (2, "Const2");
INSERT INTO t1 VALUES (3, "Const3");
INSERT INTO t2 VALUES (3, "Const3");
# Test simple '=' propagation
FLUSH STATUS;
SELECT * FROM t1, t2
WHERE t1.a = t2.a AND t2.a = 1;
a	b	a	b
1	Const1	1	Const1
FLUSH STATUS;
SELECT * FROM t1, t2
WHERE t1.a = t2.a AND t1.a = 1;
a	b	a	b
1	Const1	1	Const1
# Test OR propagation
FLUSH STATUS;
SELECT * FROM t1, t2
WHERE t1.a = t2.a AND (t2.a = 1 OR t2.a = 2);
a	b	a	b
1	Const1	1	Const1
2	Const2	2	Const2
# Test closed range propagation
FLUSH STATUS;
SELECT * FROM t1, t2
WHERE t1.a = t2.a AND t1.a >= 1 AND t1.a <=3;
a	b	a	b
1	Const1	1	Const1
2	Const2	2	Const2
3	Const3	3	Const3
# Test open range propagation
FLUSH STATUS;
SELECT * FROM t1, t2
WHERE t1.a = t2.a AND t2.a >= 1;
a	b	a	b
1	Const1	1	Const1
2	Const2	2	Const2
3	Const3	3	Const3
FLUSH STATUS;
SELECT * FROM t1, t2
WHERE t1.a = t2.a AND t2.a <= 1;
a	b	a	b
1	Const1	1	Const1
# Test IN propagation
FLUSH STATUS;
SELECT * FROM t1, t2
WHERE t1.a = t2.a and t2.a IN (1, 3);
a	b	a	b
1	Const1	1	Const1
3	Const3	3	Const3
# Same for UPDATE
FLUSH STATUS;
UPDATE t1, t2
SET t1.b = CONCAT(t1.b, ", t2.b:", t2.b)
WHERE t1.a = t2.a and t2.a IN (2, 3);
FLUSH STATUS;
UPDATE t1, t2
SET t1.b = CONCAT(t1.b, ", t2.b:", t2.b),
t2.b = CONCAT(t2.b, ", t1.b:", t1.b)
WHERE t1.a = t2.a and t2.a = 1;
FLUSH STATUS;
UPDATE t1, t2
SET t1.b = CONCAT(t1.b, ", t2.b:", t2.b),
t2.b = CONCAT(t2.b, ", t1.b:", t1.b)
WHERE t1.a = t2.a and t1.a = 2;
SELECT * FROM t1 ORDER BY a;
a	b
1	Const1, t2.b:Const1
2	Const2, t2.b:Const2, t2.b:Const2
3	Const3, t2.b:Const3
SELECT * FROM t2 ORDER BY a;
a	b
1	Const1, t1.b:Const1
2	Const2, t1.b:Const2, t2.b:Const2
3	Const3
# Same for DELETE
FLUSH STATUS;
DELETE t1 FROM t1, t2
WHERE t1.a = t2.a AND t2.a IN (1, 9);
SELECT * FROM t1 ORDER BY a;
a	b
2	Const2, t2.b:Const2, t2.b:Const2
3	Const3, t2.b:Const3
FLUSH STATUS;
DELETE t1 FROM t1, t2
WHERE t1.a = t2.a and t2.a = 2;
FLUSH STATUS;
DELETE t1 FROM t1, t2
WHERE t1.a = t2.a and t1.a = 1;
SELECT * FROM t1 ORDER BY a;
a	b
3	Const3, t2.b:Const3
SELECT * FROM t2 ORDER BY a;
a	b
1	Const1, t1.b:Const1
2	Const2, t1.b:Const2, t2.b:Const2
3	Const3
FLUSH STATUS;
DELETE t1, t2 FROM t1, t2
WHERE t1.a = t2.a and t2.a = 3;
SELECT * FROM t1 ORDER BY a;
a	b
SELECT * FROM t2 ORDER BY a;
a	b
1	Const1, t1.b:Const1
2	Const2, t1.b:Const2, t2.b:Const2
DROP TABLE t1, t2;
#
# DO is not supported by WL#4443 !!!
# Test of DO (eg. SELECT without returning values)
#
CREATE TABLE t1 (a INT, b VARCHAR(66))
PARTITION BY HASH (a) PARTITIONS 3;
INSERT INTO t1 VALUES (1, "One"), (2, "Two"), (3, "Three"), (4, "Four"), (5, "Five"), (6, "Six"), (0, "Zero");
DO (SELECT a FROM t1);
Warnings:
Error	1242	Subquery returns more than 1 row
FLUSH STATUS;
DO (SELECT @x:= b FROM t1 WHERE a = 5);
SELECT @x;
@x
Five
FLUSH STATUS;
DO (SELECT @x:= b FROM t1 WHERE a = 5 or a = 1 ORDER BY b LIMIT 1);
SELECT @x;
@x
Five
#
# SET is not supported by WL#4443 !!!
# Test of SET (eg. SELECT only setting an internal variable from
# the returning value)
#
FLUSH STATUS;
SET @x = (SELECT a FROM t1 WHERE a = 5);
SELECT @x;
@x
5
FLUSH STATUS;
SET @y = (SELECT @x:= b FROM t1 WHERE a = 5);
SELECT @x, @y;
@x	@y
Five	Five
FLUSH STATUS;
SET @y = (SELECT @x:= b FROM t1 WHERE a = 5 or a = 1 ORDER BY b LIMIT 1);
SELECT @x, @y;
@x	@y
Five	Five
DROP TABLE t1;
#
# Prepared statement
#
CREATE TABLE t1 (N int, M tinyint)
PARTITION BY HASH (N) PARTITIONS 3;
INSERT INTO t1 VALUES (1,0),(1,0),(2,0),(2,0),(3,0);
PREPARE stmt FROM 'UPDATE t1 AS P1 INNER JOIN (SELECT N FROM t1 GROUP BY N HAVING COUNT(M) > 1) AS P2 ON P1.N = P2.N SET P1.M = 2';
FLUSH STATUS;
EXECUTE stmt;
SELECT * FROM t1 ORDER BY N, M;
N	M
1	2
1	2
2	2
2	2
3	0
DEALLOCATE PREPARE stmt;
PREPARE stmt FROM 'SELECT * FROM t1 WHERE N = 2';
FLUSH STATUS;
EXECUTE stmt;
N	M
2	2
2	2
DROP TABLE t1;
# Check if we can infer from condition on partition fields that 
# no records will match.
CREATE TABLE t1 ( a int NOT NULL) PARTITION BY HASH(a) PARTITIONS 2;
INSERT INTO t1 VALUES (1),(2),(3);
FLUSH STATUS;
SELECT * FROM t1 WHERE a=5 AND a=6;
a
DROP TABLE t1;
#
# Test of subqueries in INSERT
#
CREATE TABLE t1 (a INT, b VARCHAR(64));
CREATE TABLE t2 (a INT, b VARCHAR(64)) PARTITION BY HASH (a) PARTITIONS 3;
INSERT INTO t1 VALUES (1, "test 1");
INSERT INTO t2 VALUES (SELECT * FROM t1);
ERROR 42000: You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near 'SELECT * FROM t1)' at line 1
FLUSH STATUS;
INSERT INTO t2 VALUES ((SELECT a FROM t1), (SELECT b FROM t1));
# I.e. No lock pruning possible
FLUSH STATUS;
INSERT INTO t2 VALUES (1 + (SELECT a FROM t1),
CONCAT("subq: ", (SELECT b FROM t1)));
# I.e. No lock pruning possible
SELECT * FROM t2;
a	b
1	test 1
2	subq: test 1
DROP TABLE t1, t2;
CREATE TABLE t1 (a INT, b INT) PARTITION BY HASH (a) PARTITIONS 3;
CREATE TABLE t2 (a INT, b INT) PARTITION BY HASH (a) PARTITIONS 3;
INSERT INTO t1 VALUES (1, 1), (2, 0), (4, -1), (5, 2), (7, -3), (8, -9),
(10, 5), (11, 9);
FLUSH STATUS;
INSERT INTO t2 VALUES ((SELECT max(a) FROM t1), (SELECT min(a) FROM t1));
# I.e. No lock pruning possible
FLUSH STATUS;
# I.e. No lock pruning possible
FLUSH STATUS;
INSERT INTO t2 VALUES ((SELECT a FROM t1 WHERE a = 1),
(SELECT b FROM t1 WHERE a = 2));
# I.e. No lock pruning possible on insert table
FLUSH STATUS;
# I.e. No lock pruning possible on insert table
SELECT * FROM t2 ORDER BY a, b;
a	b
1	0
11	1
DROP TABLE t1;
DROP TABLE t2;
#
# Test of SequoiaDB INSERT TABLE with non existing table in trigger
#
CREATE TABLE t1 (a INT)
ENGINE = SequoiaDB;
# Create a table to be used in a trigger on t1
CREATE TABLE t2 (a INT)
ENGINE = SequoiaDB;
# Create a trigger on t1 which uses t2
CREATE TRIGGER tr1_1_N  BEFORE INSERT ON t1
FOR EACH ROW BEGIN
UPDATE t2 SET a = 8 WHERE a > 3 LIMIT 0;
END//
# Drop t2 to cause a failure when inserting into t1
DROP TABLE t2;
INSERT INTO t1 VALUES (1);
ERROR 42S02: Table 'test_partition_locking.t2' doesn't exist
DROP TABLE t1;
CREATE TABLE t1 (a INT) PARTITION BY HASH (a) PARTITIONS 3;
INSERT INTO t1 VALUES (1), (3), (9), (2), (8), (7);
FLUSH STATUS;
CREATE TABLE t2 SELECT * FROM t1 PARTITION (p1, p2);
ERROR 0A000: Cannot specify HASH or KEY partitions
FLUSH STATUS;
CREATE TABLE t2 SELECT * FROM t1 WHERE a IN (1, 3, 9);
SELECT * FROM t2;
a
1
3
9
DROP TABLE t1, t2;
DROP DATABASE test_partition_locking;
